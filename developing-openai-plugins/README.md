# Developing OpenAI/ChatGPT plugins

Using the [http4k-connect-openai-plugin SDK](https://github.com/http4k/http4k-connect/tree/master/openai) to create
OpenAI plugins. This example includes the same example using all of
the different ChatGPT plugin styles, and installs them into the `FakeOpenAI` so you can interact with them in an
authorised way through an OpenAPI interface.

To see the plugins in action using the `FakeOpenAI`, run the `main.kt` and follow the instructions.
Or, if you want to see it running in ChatGPT from an AWS Lambda function, then install `pulumi` and run the `deploy.sh`
script, remembering to setup your AWS profile.

## Overview

http4k-connect provides an SDK for easily developing ChatGPT plugins which can be installed into ChatGPT and used as
data-sources in queries to the AI chat completion engine. Creating a plugin requires a deployed API which provides:

1. A manifest file for the plugin. This tells ChatGPT the metadata about the plugin, including legal info, the security
   model in use, and a description of the API provided by the plugin. This is served from `/.well-known/ai-plugin.json`
2. An OpenAPI specification for the plugin API. This is provided by the use of the `http4k-contract` module and is
   automatically generated by adding metadata to the various endpoints. This is served from `/openapi.json`
3. A logo file for usage in the ChatGPT UI. This is served from `/logo.png`

## Creating the plugin

The http4k-connect plugin SDK provides a simple API for creating a plugin from scratch, which is exposed as a standard
http4k `HttpHandler` type, and thus can be run in a variety of ways with zero changes, from completely in-memory (for
tests), to running as a local server, deployed as a serverless function, or integrated as a module into a larger http4k
application. Here's an example:

```kotlin
val plugin = openAiPlugin(
    // a. provide the metadata for the API
    info(
        apiVersion = "1.0",
        humanDescription = "Address book (No auth)" to "A simple unsecured example addressbook",
        modelDescription = "address_book_no_auth" to "A plugin which provides user address details for users",
        pluginUrl = Uri.of("http://mygreatapi.com"),
        contactEmail = "foobar@barfoo.com",
    ),
    // b. provide the security model for the API
    NoAuth,
    // c. provide a vararg array of endpoints for the plugin
    GetAnAddress(userDirectory),
    GetAllUsers(userDirectory)
)

plugin.asServer(Jetty(8080)).start()
```

### a. provide the metadata for the API

There is nothing special going on here - it's just metadata :)

### b. provide the security model for the API

There are 4 different security models for ChatGPT plugins that are supported. Examples of each method are provided in
this repository example:

1. No auth - access to the API is totally unauthenticated.
2. Service auth - access to the API is authenticated by the plugin owner providing API access to ChatGPT. Hence there
   are no user-level functionalities possible because the plugin knows nothing about the user.
3. User auth - access to the API is authenticated and configured by each user by providing credentials on installation
   of the plugin to their ChatGPT UI. This allows the user to "login" to the plugin and hence they can be identified and
   personalised responses given using user-private data.
4. OAuth - access to the API is authenticated and configured by each user by logging into the plugin. ChatGPT receives
   an access token from the plugin which can be used to identify and provide personalised responses given using
   user-private data.

### c. provide a vararg array of endpoints for the plugin

The API of the plugin is provided using standard http4k contract endpoints (which provide the OpenAPI definitions). Each
endpoint is just a function, and looks something like the below. For the specifics, see the
[http4k documentation](https://www.http4k.org/guide/reference/contracts/):

```kotlin
/**
 * Lookup address for a user
 */
fun GetAnAddress(userDirectory: UserDirectory) = "address" / Path.value(UserId).of("user") meta {
        summary = "Lookup the address of a user by name"
        tags += Tag("General")
        returning(OK, addressLens to "10 Downing Street, London")
    } bindContract GET to { user ->
        {
            when (val userDetails = userDirectory.find(user)) {
                null -> Response(NOT_FOUND)
                else -> Response(OK).with(addressLens of userDetails.address)
            }
        }
    }

private val addressLens = Body.string(TEXT_PLAIN).toLens()
```
